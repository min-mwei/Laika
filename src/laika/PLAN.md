# Laika initial implementation plan: Safari agent UI + MLX 4-bit model

Purpose: validate the design with a thin slice that combines a simple agent UI in Safari and local model integration.

## Scope of validation
- Safari extension + companion app with a minimal chat UI, approvals, and run status.
- Basic tool contract: observe, click, type, open_tab.
- Policy gate: allow/ask/deny with default ask for actions.
- Local model integration using an MLX 4-bit model (Qwen3-0.6B) built via `src/local_llm_quantizer`.
- Package the MLX model directory for the initial phase and run inference locally via `mlx-swift`.
- Redacted context pack only; no cookies or session tokens.

## Non-goals for this validation
- Full autopilot, multi-modal inputs, or long-run resume.
- Full security hardening, downloads, or file uploads.
- Cloud inference providers or runtime switching.
- AI21-Jamba2-3B integration (defer until MLX pipeline is validated).

## Proposed architecture (thin slice)
- Safari extension (content script + background)
  - observe_dom -> structured elements + visible text + page URL
  - action tools -> click/type/scroll by element handle
  - overlay -> highlight target and show approval state
- macOS app (SwiftUI)
  - toolbar popover + small companion window
  - agent loop: observe -> model -> policy -> propose -> execute
  - run log: SQLite or JSONL append (small)
  - policy gate: static rules + per-site mode (Observe/Assist)
- Native messaging bridge
  - Safari Web Extension uses `browser.runtime.sendNativeMessage` to reach the native handler
  - Native handler calls the Agent Core and returns typed responses
- Model service
  - Swift XPC worker (no network entitlement) that uses `mlx-swift` to load the MLX 4-bit model directory
  - model directory generated by `src/local_llm_quantizer/convert_qwen3_to_mlx_4bit.py`
  - validate mlx-swift can load the converted model format; adjust packaging if needed
  - prompt contract: tool-only JSON; no free-form actions
  - output validation + retry on invalid JSON

## Implementation steps
1. Repo scaffolding
   - Create `src/laika` with Swift and extension project structure.
   - Define shared tool schema JSON (versioned) and message envelopes.
   - Add a minimal run log (JSONL or SQLite).
   - Success: extension can send/receive typed messages to the native handler.

2. Minimal Safari UI
   - Toolbar popover with prompt input, run status, approvals list.
   - Companion window with chat log and action queue.
   - Show "Observe/Assist" mode per site.
   - Success: entering a prompt triggers an observe->model->propose loop.

3. Observe-only tool
   - Content script collects visible text + interactive elements (role, label, bbox).
   - observe_dom returns a bounded context pack (size cap, no raw HTML).
   - Success: model can answer "summarize this page" with citations (element IDs or URLs).

4. Assist-mode actions
   - Implement element handles scoped to (tabId, origin, documentId).
   - Tools: browser.click, browser.type, browser.open_tab, browser.scroll.
   - Policy gate: allow observe; ask for actions; deny sensitive fields by default.
   - Success: user can approve a proposed click/type step and see highlight before execute.

5. MLX 4-bit model packaging + Swift runtime
   - Use `src/local_llm_quantizer` to convert Qwen3-0.6B to MLX 4-bit:
     - `python convert_qwen3_to_mlx_4bit.py --out-dir ./Qwen3-0.6B-MLX-4bit`
     - Requires Apple Silicon + `mlx_lm` (see `src/local_llm_quantizer/README.md`).
   - Run `python smoke_test_mlx_model.py --model-dir ./Qwen3-0.6B-MLX-4bit`.
   - Place the converted model directory under `src/laika/model_assets/Qwen3-0.6B-MLX-4bit` (or app resources) for the initial phase.
   - Implement the MLX runtime in Swift using `mlx-swift-lm`; wire it to the native messaging handler (and later the XPC worker).
   - Validate that `mlx-swift` can load the converted directory; if not, add a packaging step or converter adjustments.
   - Success: MLX model proposes tool calls and a short plan for 2-3 step tasks.

6. Validation scenarios
   - Wikipedia search and navigation.
   - GitHub repo browsing (read-only).
   - Form fill on a dummy site (Assist with approval).
   - Measure: tool call latency, message sizes, highlight accuracy.

## Acceptance criteria
- End-to-end loop works on Safari: prompt -> observe -> model -> approve -> action.
- No cookies or session tokens leave the browser; context pack contains only redacted text.
- Tool calls are schema-validated and blocked by policy on sensitive actions.
- MLX 4-bit model loads from the packaged directory via `mlx-swift`; smoke test passes.
- Local inference responds within a reasonable latency (under 10s for small prompts on M-series).

## Follow-ups after validation
- Add AI21-Jamba2-3B integration once MLX packaging and tool-use loop are stable.
- Expand tool coverage, add screenshot-based grounding, and harden policy gate.
- Replace JSONL with SQLite run log and add checkpointing.
- Add a probe harness for Safari capability testing.
